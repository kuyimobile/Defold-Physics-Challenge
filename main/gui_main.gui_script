local gooey = require "gooey.gooey"
-- game result
local RESULT_WIN = 1
local RESULT_LOSS = 2
local SCREEN_TITLE = 1
local SCREEN_GAME = 2
-- button
local COLOR_PRESSED = vmath.vector4( 128/255, 128/255, 128/255, 255/255 )
local COLOR_RELEASED = vmath.vector4( 255/255, 255/255, 255/255, 255/255 )
-- tutorial
local TUT_NONE = 0
local TUT_MOVE = 1
local TUT_ACCEL = 2

function init(self)
	msg.post( ".", "acquire_input_focus" )
	msg.post( ".", "delay_init" )
end

function on_message(self, message_id, message, sender)
	if ( message_id == hash( "delay_init" ) ) then
		self.S_WIDTH = tonumber(sys.get_config_int( "display.width" ))
		self.S_HEIGHT = tonumber(sys.get_config_int( "display.height" ))
		gui.set_enabled( gui.get_node( "root_levcom" ), false )
		gui.set_enabled( gui.get_node( "root_levcom_sub" ), false )
		gui.set_enabled( gui.get_node( "root_progress" ), false )
		gui.set( gui.get_node( "btn_chest" ), "color", vmath.vector4( 222/255, 183/255, 29/255, 1 ) )
		if ( constants.cur_screen == SCREEN_TITLE ) then
			gui.set_enabled( gui.get_node( "root_title" ), true )
		else
			gui.set_enabled( gui.get_node( "root_title" ), false )
		end
		gui.set_enabled( gui.get_node( "root_tutorial" ), false )
		gui.set_text( gui.get_node( "text_version_main" ), constants.VERSION )
		gui.set_text( gui.get_node( "text_version_title" ), constants.VERSION )
		self.tutorial_mode = TUT_NONE
	elseif ( message_id == hash( "set_debug" ) ) then
		--gui.set_text( gui.get_node( "text_version_main" ), message.str )
		--gui.set_text( gui.get_node( "text_version_main" ), constants.debug_text )
	elseif ( message_id == hash( "update_zoom" ) ) then
		local node_version_main = gui.get_node( "text_version_main" )
		local node_version_title = gui.get_node( "text_version_title" )
		local pos_version = gui.get_position( node_version_main )
		local window_width, window_height = window.get_size()
		pos_version.x, pos_version.y = 0, 6 - 418
		if ( window_width / self.S_WIDTH < window_height / self.S_HEIGHT ) then
			pos_version.y = pos_version.y - ( window_height / message.zoom - self.S_HEIGHT ) * 0.5
		else
			--pos_version.x = pos_version.x + ( window_width  / message.zoom - self.S_WIDTH ) * 0.5
		end
		if ( pos_version.y < -532 ) then
			pos_version.y = -532
		end
		gui.set_position( node_version_main, pos_version )
		gui.set_position( node_version_title, pos_version )
		gui.set_position( gui.get_node( "corner_confetti" ), pos_version )
	elseif ( message_id == hash( "update_level" ) ) then
		gui.set_enabled( gui.get_node( "btn_reset" ), true )
		gui.set_enabled( gui.get_node( "btn_accel" ), true )
		gui.set_text( gui.get_node( "text_level" ), constants.cur_level_main .. " - " .. constants.cur_level_sub )
	elseif ( message_id == hash( "on_level_complete" ) ) then
		gui.set_enabled( gui.get_node( "btn_reset" ), false )
		gui.set_enabled( gui.get_node( "btn_accel" ), false )
		gui.play_flipbook( gui.get_node( "msg_result" ), "text_try_again" )
		gui.play_flipbook( gui.get_node( "btn_replay" ), "btn_retry" )
		self.is_chest_enabled = false
		if ( message.result == RESULT_LOSS or message.is_level_main ) then
			if ( message.result == RESULT_WIN ) then
				gui.play_particlefx( gui.get_node( "confetti" ) )
				gui.play_flipbook( gui.get_node( "msg_result" ), "text_great" )
				gui.play_flipbook( gui.get_node( "btn_replay" ), "btn_play" )
			end
			gui.set_enabled( gui.get_node( "root_levcom" ), true )
		elseif ( message.result == RESULT_WIN and not message.is_level_main ) then
			gui.play_particlefx( gui.get_node( "corner_confetti" ) )
			gui.set_enabled( gui.get_node( "root_levcom_sub" ), true )
		end
		gui.set_enabled( gui.get_node( "btn_replay" ), true )

		local cur_level_sub = constants.cur_level_sub - ( message.result == RESULT_LOSS and 0 or 1 )
		local cur_level_main = constants.cur_level_main - 1
		--[[
		if ( message.result == RESULT_WIN and not message.is_tutorial_level and cur_level_main < 7 ) then
			gui.set_enabled( gui.get_node( "root_progress" ), true )
			local node_bar_mask = gui.get_node( "bar_mask" )
			local node_bar_fill = gui.get_node( "bar_fill" )
			local node_chest = gui.get_node( "btn_chest" )
			local node_reward = gui.get_node( "chest_reward" )
			local node_dot = gui.get_node( "dot_" .. cur_level_sub )
			local size = gui.get_size( node_bar_fill )
			local segment = 45
			local duration_fill = 0.5

			-- reset properties
			if ( cur_level_sub >= 3 and cur_level_main < 7 ) then
				gui.set_enabled( gui.get_node( "btn_replay" ), false )
			end
			for i = 1, 3 do
				gui.play_flipbook( gui.get_node( "dot_" .. i ), i < cur_level_sub and "chest_dot_star" or "chest_dot" )
			end
			gui.set( node_chest, "scale.y", 1 )
			gui.play_flipbook( node_chest, "chest_closed" )
			self.is_btn_chest_animating = false
			
			if ( cur_level_sub >= 3 and cur_level_main < 7 ) then
				self.is_chest_enabled = true
				msg.post( ".", "show_hint_chest" )
			end
			gui.set_enabled( node_reward, false )
			gui.set_scale( node_reward, vmath.vector3( 0.1 ) )
			
			gui.set( node_bar_mask, "position.x", - size.x + ( cur_level_sub - 1 ) * segment )
			gui.set( node_bar_fill, "position.x", size.x - ( cur_level_sub - 1 ) * segment )
			gui.animate( node_bar_mask, "position.x", - size.x + cur_level_sub * segment, gui.EASING_LINEAR, duration_fill )
			gui.animate( node_bar_fill, "position.x", size.x - cur_level_sub * segment, gui.EASING_LINEAR, duration_fill, 0, function() 
				gui.play_flipbook( node_dot, "chest_dot_star" )
				gui.set_scale( node_dot, vmath.vector3( 0.1 ) )
				gui.animate( node_dot, "scale", 0.9, gui.EASING_OUTBACK, 0.2 )
			end )
		end
		]]--
	elseif ( message_id == hash( "open_chest" ) ) then
		self.is_chest_enabled = false
		local node_chest = gui.get_node( "btn_chest" )
		local node_reward = gui.get_node( "chest_reward" )
		local cur_level_sub = constants.cur_level_sub - ( message.result == RESULT_LOSS and 0 or 1 )
		local cur_level_main = constants.cur_level_main - 1
		gui.animate( node_chest, "scale.y", 0.5, gui.EASING_LINEAR, 0.15, 0.25, function()
			sound.play( "/sounds#win", { delay = 0, gain = constants.SFX_GAIN } )
			gui.play_flipbook( node_chest, "chest_open" )
			gui.animate( node_chest, "scale.y", 1, gui.EASING_OUTBACK, 0.25 )
			local pos_chest = gui.get_position( node_chest )
			pos_chest.y = pos_chest.y + 42
			gui.play_flipbook( gui.get_node( "chest_item" ), "chest_item" .. cur_level_main )
			gui.set_enabled( node_reward, true )
			gui.set_position( node_reward, pos_chest )
			gui.animate( node_reward, "position.y", pos_chest.y + 90, gui.EASING_OUTCUBIC, 0.25, 0, function()
				gui.set_enabled( gui.get_node( "btn_replay" ), true )
			end )
			gui.animate( node_reward, "scale", vmath.vector3( 1 ), gui.EASING_OUTCUBIC, 0.25 )
		end )
	elseif ( message_id == hash( "set_tutorial_mode" ) ) then
		self.tutorial_mode = message.tutorial_mode
		if ( self.tutorial_mode ~= TUT_NONE ) then
			gui.set_text( gui.get_node( "text_level" ), " - " )
		end
	elseif ( message_id == hash( "show_tutorial" ) ) then
		self.tutorial_mode = message.tutorial_mode
		local node_grp_hand = gui.get_node( "grp_hand" )
		local node_hand = gui.get_node( "hand" )
		local node_ring = gui.get_node( "ring" )
		local pos_orig = gui.get_position( node_hand )
		self.tutorial_mode = message.tutorial_mode
		gui.set_enabled( gui.get_node( "root_tutorial" ), true )
		local duration_hand = 1.6
		local duration_ring = duration_hand * 0.5
		local function animate_ring()
			gui.cancel_animation( node_hand, "position.y" )
			gui.cancel_animation( node_ring, "color.w" )
			gui.cancel_animation( node_ring, "scale" )

			gui.set( node_hand, "position.y", pos_orig.y )
			gui.set( node_ring, "color.w", 1 )
			gui.set_scale( node_ring, vmath.vector3( 0.2, 0.2, 0.2 ) )

			gui.animate( node_hand, "position.y", pos_orig.y - 10, go.EASING_LINEAR, duration_hand, 0, function() end, gui.PLAYBACK_ONCE_PINGPONG )
			gui.animate( node_ring, "color.w", 0, go.EASING_LINEAR, duration_ring, 0, function() end, gui.PLAYBACK_ONCE_FORWARD )
			gui.animate( node_ring, "scale", 0.5, go.EASING_LINEAR, duration_ring, 0, function()
				if ( self.timer_ring ) then
					timer.cancel( self.timer_ring )
					self.timer_ring = nil
				end
				self.timer_ring = timer.delay( duration_ring, false, function() 
					animate_ring()
					if ( self.tutorial_mode == TUT_ACCEL ) then
						self.is_btn_accel_animating = false
						msg.post( ".", "show_hint_accel" )
					end
				end )
			end, gui.PLAYBACK_ONCE_FORWARD )
		end
		animate_ring()
	elseif ( message_id == hash( "hide_tutorial" ) ) then
		gui.set_enabled( gui.get_node( "root_tutorial" ), false )
	elseif ( message_id == hash( "show_hint_chest" ) and not self.is_btn_chest_animating ) then
		self.is_btn_chest_animating = true
		local node_chest = gui.get_node( "btn_chest" )
		local duration = 0.05
		local val = 10
		local ctr = 10
		local function wiggle_chest()
			gui.animate( node_chest, "euler.z", val, gui.EASING_LINEAR, duration, 0, function() 
				if ( val ~= 0 ) then
					val = ctr <= 1 and 0 or val * -0.9
				end
				if ( ctr ~= 0 and self.is_btn_chest_animating ) then
					ctr = ctr - 1
					wiggle_chest()
				else
					self.is_btn_chest_animating = false
					self.timer_chest = timer.delay( 1, false, function() 
						msg.post( ".", "show_hint_chest" )
					end )
				end
			end )
		end
		wiggle_chest()
	elseif ( message_id == hash( "hide_hint_chest" ) ) then
		local node_chest = gui.get_node( "btn_chest" )
		self.is_btn_accel_animating = false
		gui.cancel_animation( node_chest, "euler.z" )
		gui.set( node_chest, "euler.z", 0 )
		if ( self.timer_chest ) then
			timer.cancel( self.timer_chest )
			self.timer_chest = nil
		end
	elseif ( message_id == hash( "show_hint_accel" ) and not self.is_btn_accel_animating ) then
		local node_accel = gui.get_node( "btn_accel" )
		gui.cancel_animation( node_accel, "position.x" )
		self.is_btn_accel_animating = true
		if ( not self.btn_accel_pos ) then
			local pos = gui.get_position( node_accel )
			self.btn_accel_pos = pos
		end
		local duration = 0.05
		local val = 10
		local ctr = 10
		local function wiggle_obj()
			gui.animate( node_accel, "position.x", self.btn_accel_pos.x + val, gui.EASING_LINEAR, duration, 0, function() 
				if ( val ~= 0 ) then
					val = val * -0.9
				end
				if ( ctr ~= 0 and self.is_btn_accel_animating ) then
					ctr = ctr - 1
					wiggle_obj()
				else
					self.is_btn_accel_animating = false
				end
			end )
		end
		wiggle_obj()
	elseif ( message_id == hash( "hide_hint_accel" ) and self.is_btn_accel_animating ) then
		local node_accel = gui.get_node( "btn_accel" )
		self.is_btn_accel_animating = false
		gui.cancel_animation( node_accel, "position.x" )
		if ( self.btn_accel_pos ) then
			gui.set_position( node_accel, self.btn_accel_pos )
		end
	elseif ( message_id == hash( "clear_level" ) ) then
		gui.set_enabled( gui.get_node( "root_levcom" ), false )
		gui.set_enabled( gui.get_node( "root_levcom_sub" ), false )
		gui.set_enabled( gui.get_node( "root_progress" ), false )
	end
end

local function update_button( button )
	if button.over_now then
		
	elseif button.out_now then
		
	elseif button.pressed_now then
		sound.play( "/sounds#click", { delay = 0, gain = constants.SFX_GAIN } )
		gui.set_color( button.node, COLOR_PRESSED )
	elseif button.released_now then
		gui.set_color( button.node, COLOR_RELEASED )
	end
end

function on_input(self, action_id, action)
	if ( constants.cur_screen == SCREEN_GAME ) then
		gooey.button( "btn_reset", action_id, action, function( button )
			if ( button.released_now and self.tutorial_mode == TUT_NONE ) then
				msg.post( "controller#main", "reset_dummy" )
				-- update_button( gooey.button( "btn_accel" ).set_visible( false ) )
			end
		end, update_button )

		gooey.button( "btn_accel", action_id, action, function( button )
			if ( button.released_now and self.tutorial_mode ~= TUT_MOVE ) then
				msg.post( "controller#main", "accel_wall" )
				if ( self.tutorial_mode == TUT_ACCEL ) then
					msg.post( ".", "hide_hint_accel" )
					self.tutorial_mode = TUT_NONE
					gui.set_enabled( gui.get_node( "grp_hand" ), false )
				end
			end
		end, update_button )

		gooey.button( "btn_replay", action_id, action, function( button )
			if ( button.released_now ) then
				msg.post( "controller#main", "reset_level" )
			end
		end, update_button )

		gooey.button( "btn_sound", action_id, action, function( button )
			local btn_sound = gui.get_node( "btn_sound" )
			if ( button.released_now ) then
				if ( constants.SFX_GAIN == 1 ) then
					constants.SFX_GAIN = 0
					gui.play_flipbook( btn_sound, "btn_sound_off" )
					sound.stop( "/sounds#mus_main" )
				else
					constants.SFX_GAIN = 1.0
					gui.play_flipbook( btn_sound, "btn_sound" )
					--sound.play( "/sounds#mus_main", { delay = 0, gain = constants.MUS_GAIN } )
				end
			end
		end, update_button )

		gooey.button( "btn_home", action_id, action, function( button )
			if ( button.released_now ) then
				if ( self.tutorial_mode == TUT_NONE ) then
					sound.stop( "/sounds#mus_main" )
					gui.set_enabled( gui.get_node( "root_title" ), true )
					constants.cur_screen = SCREEN_TITLE
					msg.post( "controller#main", "pause_game" )
				end
			end
		end, update_button )

		gooey.button( "btn_chest", action_id, action, function( button )
			if ( button.released_now and self.is_chest_enabled ) then
				msg.post( ".", "hide_hint_chest" )
				msg.post( ".", "open_chest" )
			end
		end, function ( button) 
			if button.pressed_now and self.is_chest_enabled then
				sound.play( "/sounds#click", { delay = 0, gain = constants.SFX_GAIN } )
			end
		end )
	elseif ( constants.cur_screen == SCREEN_TITLE ) then
		gooey.button( "btn_play", action_id, action, function( button )
			if ( button.released_now ) then
				gui.set_enabled( gui.get_node( "root_title" ), false )
				constants.cur_screen = SCREEN_GAME
				msg.post( "controller#main", "resume_game" )
			end
		end, update_button )
	end
end